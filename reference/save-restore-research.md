# Save/Restore Research: ifvms.js and GlkOte Implementation

**Date:** December 17, 2024
**Purpose:** Research how ifvms.js and GlkOte handle save/restore to inform IFTalk's implementation

---

## Executive Summary

### Key Findings

1. **GlkOte's `save_allstate()` does NOT save window content** - it only saves metadata (metrics, command history, default colors)
2. **ifvms.js has built-in autosave support** through `do_autosave()` and `do_autorestore()` functions
3. **Window content must be saved separately** - neither the Z-machine nor Glk specification includes display content in save files
4. **IFTalk's HTML-saving approach is necessary and correct** - this is the standard solution for web interpreters

### Recommendation

**IFTalk's current implementation is sound.** The issue is NOT with the approach, but likely with **timing** or **event handling** during the restore process.

---

## How ifvms.js + GlkOte Autosave Works

### Standard Autosave Architecture

**ifvms.js (zvm.js) provides:**

```javascript
do_autosave(save) {
    const snapshot = {
        ram: this.save_file(this.pc, 1),      // VM memory state (Quetzal format)
        glk: this.Glk.save_allstate(),        // Glk metadata
        io: clone(this.io),                   // I/O state
        read_data: clone(this.read_data),     // Read data buffer
        xorshift_seed: this.xorshift_seed     // RNG seed
    };

    this.options.Dialog.autosave_write(signature, snapshot);
}
```

**GlkOte (glkote.js) provides:**

```javascript
glkote_save_allstate() {
    return {
        metrics: {
            width: current_metrics.width,
            height: current_metrics.height
        },
        history: {},      // Command history per window
        defcolor: {}      // Default colors per window
    };
}
```

**What's MISSING:** The actual window content (text on screen) is NOT included in either system.

---

## Why Window Content Isn't Saved by Default

### Z-Machine Architecture

The Z-machine spec defines save files (Quetzal format) to contain:
- **IFhd chunk**: Story identification (release, serial, checksum)
- **Memory chunk**: RAM state (compressed by XOR with original)
- **Stacks chunk**: Call frames and local variables

**Window content is NOT part of the save file** because:
1. The Z-machine assumes it can regenerate output by continuing execution
2. Traditional interpreters (Frotz, Zoom) redraw the current location on restore
3. Text is considered ephemeral display state, not game state

### Glk Architecture

Glk's `save_allstate()` only saves **window structure metadata**:
- Window dimensions and metrics
- Style and color settings
- Command history (for recall)

**Window content (actual text) is NOT saved** because:
1. Glk treats windows as "views" into the game state
2. Content is expected to be regenerated by the game
3. The game engine outputs current location after restore

---

## How Web Interpreters Handle This

### The Problem

After restoring VM state:
1. ZVM continues execution from saved PC
2. Game outputs current location description
3. This overwrites the restored window content
4. User sees only current location, not previous commands

### The Solution (Terp-Managed Saves)

Web interpreters must:
1. **Save window content separately** (HTML or text)
2. **Restore window content after VM restore**
3. **Suppress post-restore game output** (first update after restore)

**Source:** [Interpreter-Managed Saves in Glk](https://www.eblong.com/zarf/glk/terp-saving-notes.html)

Quote: "The I/O state must include the same number of windows, same text visible in the windows, same files open, etc."

---

## IFTalk's Implementation Analysis

### Current Approach (Correct ✅)

**File:** `public/js/game/save-manager.js`

```javascript
// Save
autoSave() {
    const quetzalData = window.zvmInstance.save_file(pc);
    const saveData = {
        quetzalData: base64Data,
        narrationState: {
            currentChunkIndex: state.currentChunkIndex,
            chunksLength: state.narrationChunks.length
        },
        displayHTML: {
            statusBar: statusBarEl?.innerHTML || '',
            upperWindow: upperWindowEl?.innerHTML || '',
            lowerWindow: lowerWindowEl?.innerHTML || ''
        }
    };
    localStorage.setItem(key, JSON.stringify(saveData));
}

// Restore
autoLoad() {
    window.zvmInstance.restore_file(bytes.buffer);

    // Restore HTML content
    statusBarEl.innerHTML = saveData.displayHTML.statusBar;
    upperWindowEl.innerHTML = saveData.displayHTML.upperWindow;
    lowerWindowEl.innerHTML = saveData.displayHTML.lowerWindow;

    // Suppress next update
    window.ignoreNextVoxGlkUpdate = true;
}
```

**File:** `public/js/game/voxglk.js`

```javascript
update(arg) {
    if (window.ignoreNextVoxGlkUpdate) {
        console.log('[VoxGlk] ignoreNextVoxGlkUpdate flag is set, skipping render');
        window.ignoreNextVoxGlkUpdate = false;
        return;
    }
    // ... normal rendering ...
}
```

### Why This Approach is Correct

1. ✅ **Saves HTML content** - Preserves actual text on screen
2. ✅ **Restores HTML after VM restore** - Puts text back
3. ✅ **Suppresses post-restore output** - Prevents overwriting
4. ✅ **Saves narration state** - Continues from correct chunk

This is exactly what the Glk documentation recommends for terp-managed saves.

---

## Comparison with Standard ifvms.js Autosave

### Standard Approach (if Dialog.autosave_write/read implemented)

```javascript
// In zvm.js
do_autosave() {
    snapshot = {
        ram: save_file(pc, 1),
        glk: Glk.save_allstate(),  // ← Only metadata!
        io: clone(io),
        read_data: clone(read_data)
    };
    Dialog.autosave_write(signature, snapshot);
}

do_autorestore(snapshot) {
    restore_file(snapshot.ram);
    Glk.restore_allstate(snapshot.glk);  // ← Only metadata!
    this.io = snapshot.io;
    this.read_data = snapshot.read_data;
}
```

### IFTalk's Custom Approach

```javascript
// In save-manager.js
autoSave() {
    quetzalData = zvmInstance.save_file(pc);
    displayHTML = {
        statusBar: statusBarEl.innerHTML,
        upperWindow: upperWindowEl.innerHTML,
        lowerWindow: lowerWindowEl.innerHTML
    };
    localStorage.setItem(key, {quetzalData, displayHTML});
}

autoLoad() {
    zvmInstance.restore_file(bytes);
    statusBarEl.innerHTML = displayHTML.statusBar;
    upperWindowEl.innerHTML = displayHTML.upperWindow;
    lowerWindowEl.innerHTML = displayHTML.lowerWindow;
    ignoreNextVoxGlkUpdate = true;
}
```

### Key Differences

| Aspect | Standard ifvms.js | IFTalk Custom |
|--------|------------------|---------------|
| **VM State** | ✅ `save_file()` | ✅ `save_file()` |
| **Glk Metadata** | ✅ `save_allstate()` | ❌ Not used |
| **Window Content** | ❌ NOT saved | ✅ HTML saved |
| **Output Suppression** | ❓ App-dependent | ✅ `ignoreNextVoxGlkUpdate` |
| **Storage** | `Dialog.autosave_*` | `localStorage` directly |

**Verdict:** IFTalk's approach is more complete because it saves window content, which the standard approach does NOT.

---

## Why IFTalk's Implementation Might Not Be Working

### Potential Issues

1. **Timing Issue:** The `ignoreNextVoxGlkUpdate` flag might be cleared before the update arrives
2. **Multiple Updates:** The game might send multiple updates after restore, but we only ignore the first
3. **Race Condition:** HTML restore might happen before/after DOM is ready
4. **Event Ordering:** VoxGlk update might be called before `autoLoad()` finishes

### Debugging Steps

1. **Check flag lifetime:**
   ```javascript
   console.log('[SaveManager] Set ignoreNextVoxGlkUpdate =', window.ignoreNextVoxGlkUpdate);
   ```

2. **Count updates after restore:**
   ```javascript
   // In voxglk.js
   if (window.ignoreNextVoxGlkUpdate) {
       console.log('[VoxGlk] Update #', updateCount, 'after restore');
   }
   ```

3. **Log HTML before/after:**
   ```javascript
   console.log('[SaveManager] Before restore:', lowerWindowEl.innerHTML.length, 'chars');
   lowerWindowEl.innerHTML = saveData.displayHTML.lowerWindow;
   console.log('[SaveManager] After restore:', lowerWindowEl.innerHTML.length, 'chars');
   ```

4. **Verify update is actually suppressed:**
   ```javascript
   // In voxglk.js update()
   if (window.ignoreNextVoxGlkUpdate) {
       console.log('[VoxGlk] SKIPPING UPDATE - flag was set');
       window.ignoreNextVoxGlkUpdate = false;
       return;  // Make sure this return actually executes
   }
   ```

---

## Alternative Approaches to Consider

### 1. Queue-Based Restoration

Instead of ignoring the next update, queue the restored content and apply it AFTER updates settle:

```javascript
autoLoad() {
    zvmInstance.restore_file(bytes);

    // Queue restoration for after all pending updates
    window.pendingHTMLRestore = saveData.displayHTML;

    setTimeout(() => {
        if (window.pendingHTMLRestore) {
            applyHTMLRestore(window.pendingHTMLRestore);
            window.pendingHTMLRestore = null;
        }
    }, 100);
}
```

### 2. Update Counter

Ignore first N updates instead of just one:

```javascript
window.ignoreVoxGlkUpdateCount = 2;

// In voxglk.js
if (window.ignoreVoxGlkUpdateCount > 0) {
    console.log('[VoxGlk] Ignoring update', window.ignoreVoxGlkUpdateCount);
    window.ignoreVoxGlkUpdateCount--;
    return;
}
```

### 3. Content Comparison

Compare new output with saved content, skip if identical:

```javascript
update(arg) {
    if (window.restoredHTML) {
        const newContent = extractContent(arg);
        const savedContent = window.restoredHTML;
        if (contentMatches(newContent, savedContent)) {
            console.log('[VoxGlk] Skipping duplicate content');
            return;
        }
    }
    // ... normal rendering ...
}
```

### 4. Use GlkOte's Autorestore Feature

Pass restored content in first update's `autorestore` field:

```javascript
// On first update after restore
const firstUpdate = {
    type: 'update',
    gen: 0,
    windows: [...],
    autorestore: {
        metrics: {...},
        history: {...},
        content: {  // ← Add this (not standard)
            statusBar: savedHTML.statusBar,
            upperWindow: savedHTML.upperWindow,
            lowerWindow: savedHTML.lowerWindow
        }
    }
};
```

Then in VoxGlk, check for `autorestore.content` and apply it.

---

## Recommendations

### Immediate Actions

1. **Add comprehensive logging** to track the exact sequence of events:
   - When `autoLoad()` starts/ends
   - When HTML is restored
   - When `ignoreNextVoxGlkUpdate` is set/cleared
   - When `voxglk.update()` is called and whether it's skipped

2. **Test with the TODO.md test case:**
   - Clear localStorage
   - Load game
   - Hit enter 3 times
   - Refresh browser
   - Check console logs for flag state

3. **Verify the timing** of when `restore_file()` triggers updates:
   - Does it call `update()` synchronously or asynchronously?
   - How many times is `update()` called after restore?

### Long-Term Improvements

1. **Consider using ifvms.js's built-in autosave** but extend it:
   ```javascript
   // Extend Dialog.autosave_write
   Dialog.autosave_write = function(key, snapshot) {
       snapshot.displayHTML = captureHTML();
       localStorage.setItem('iftalk_auto_' + key, JSON.stringify(snapshot));
   };
   ```

2. **Implement GlkOte.save_allstate() properly** to save all state:
   ```javascript
   GlkOte.save_allstate = function() {
       return {
           metrics: current_metrics,
           history: windowdic.history,
           defcolor: windowdic.defcolor,
           content: captureWindowContent()  // ← Add this
       };
   };
   ```

3. **Add retry logic** if first restore attempt fails:
   ```javascript
   if (!contentMatchesExpected()) {
       console.warn('[SaveManager] Retrying HTML restore...');
       setTimeout(() => applyHTMLRestore(), 50);
   }
   ```

---

## Critical Finding: Z-machine vs Glulx Autosave Support

**Date:** December 17, 2024
**Finding:** ifvms.js's built-in autosave **ONLY works for Glulx games, NOT Z-machine games**

### The Problem

When attempting to use ifvms.js's built-in `do_autosave()` system for Z-machine games (Anchorhead, Lost Pig, etc.), we encountered this error:

```
TypeError: Cannot read properties of null (reading 'get_retained_array')
    at Object.save_allstate (glkapi.js:817:32)
    at newClass.do_autosave (zvm.js:3067:19)
```

### Root Cause

The `save_allstate()` function in glkapi.js requires **GiDispa** (Glulx dispatch layer):

```javascript
// glkapi.js:817 - Inside save_allstate()
if (win.linebuf !== null) {
    var info = GiDispa.get_retained_array(win.linebuf);  // ← GiDispa is null for Z-machine!
    obj.linebuf = { /* ... */ };
}
```

**GiDispa only exists for Glulx games.** Z-machine games don't have a dispatch layer, so:
- `GiDispa` is `null`
- `save_allstate()` crashes when trying to save line buffers
- Built-in autosave is **fundamentally incompatible** with Z-machine

### Why This Matters

IFTalk primarily uses **Z-machine games** (.z3, .z5, .z8 files):
- ❌ Lost Pig (Z8)
- ❌ Anchorhead (Z5)
- ❌ Zork series (Z3/Z5)
- ✅ Would work for Glulx (.ulx, .gblorb) games (but we don't use them)

### Attempted Workaround

We tried triggering autosave only during line input to avoid invalid states:

```javascript
// glkapi.js - Our attempted fix
if (VM && VM.do_autosave && has_line_input) {
    console.log('[GlkAPI] Z-machine game with line input, triggering autosave');
    VM.do_autosave(1);  // ← Still crashes in save_allstate()
}
```

This didn't help because `save_allstate()` is called internally and still requires GiDispa.

### Solution: Custom Autosave System

**IFTalk's custom save-manager.js is the correct approach for Z-machine games:**

```javascript
// voxglk.js - Manual autosave after each turn
if (!shouldSkipAutosave && !skipFirstAutosave && !shouldSkipAfterRestore) {
    setTimeout(async () => {
        const { autoSave } = await import('./save-manager.js');
        await autoSave();  // Custom save: VM state + HTML + narration state
    }, 100);
}

// game-loader.js - Disable ifvms.js autosave
const options = {
    vm: vm,
    Glk: window.Glk,
    GlkOte: voxglk,
    Dialog: window.Dialog,
    do_vm_autosave: false  // Disabled - doesn't work for Z-machine
};
```

### Key Takeaways

1. **ifvms.js autosave is Glulx-only** - Not a bug, architectural limitation
2. **Z-machine games need custom autosave** - Save HTML separately, suppress post-restore output
3. **IFTalk's approach is correct** - Our custom save-manager.js is the proper solution
4. **Don't try to use do_vm_autosave for Z-machine** - It will crash in save_allstate()

### For Future Reference

If IFTalk ever supports Glulx games:
- Glulx games CAN use `do_vm_autosave: true`
- GiDispa will exist and `save_allstate()` will work
- Would still need to extend with HTML content via Dialog.autosave_write/read

---

## Conclusion

**IFTalk's custom save-manager.js implementation is architecturally correct and necessary.** The approach of saving HTML content separately and suppressing post-restore output is the standard solution for web-based IF interpreters, and is the **only viable approach for Z-machine games**.

The system works correctly for Z-machine games (which IFTalk uses) and cannot be replaced with ifvms.js's built-in autosave due to fundamental architectural differences between Z-machine and Glulx.

---

## Dialog.open and Native Save/Restore (December 2024)

### The Problem: Game-Triggered Save/Restore

Some games (like Anchorhead) have intro screens that say "Press R to restore". When the user presses R:

1. Game processes 'R' key input
2. Game calls `Dialog.open(false, 'save', gameid, callback)` for restore
3. Dialog implementation should show file picker
4. User selects file or cancels
5. `callback(fileref)` or `callback(null)` is called
6. Game continues with result

### Parchment's Approach

Parchment (iplayif.com) handles this with a **proper modal dialog**:

1. `Dialog.open()` creates a modal overlay with file picker UI
2. Modal **blocks** interaction with the game
3. User selects file or clicks Cancel
4. `callback()` is called with result
5. Modal closes, game continues

When cancelled with no saves:
- Game shows "Restore failed."
- Game continues to intro text
- Input mode changes to line input for commands

### IFTalk's Failed Approaches

We tried several approaches that didn't work:

#### Approach 1: Async Event with Custom UI
```javascript
// dialog-stub.js
window.dispatchEvent(new CustomEvent('iftalk-dialog-open', {
  detail: { callback, markAsync: () => { state.async = true; } }
}));

// commands.js
markAsync();  // Tell dialog we'll call callback later
handleRestoreCommand();  // Show our UI
// Later... callback(null);  // Complete dialog
```

**Problem:** Game state machine got corrupted. After callback(null), game would freeze or enter wrong input mode. The async nature broke the expected synchronous flow.

#### Approach 2: Secret Snapshot
```javascript
// Before showing UI, capture VM state
captureSecretSnapshot();
// Show our UI
// On cancel, restore from snapshot and call callback
restoreSecretSnapshot(callback);
```

**Problem:** Snapshot was captured AFTER the user pressed 'R', so restoring put the game in "mid-restore operation" state, not back to the intro. Calling callback(null) after restore caused unpredictable behavior.

#### Approach 3: Display-Only Restore
```javascript
// Only restore display HTML, not VM state
restoreDisplayHTML();
callback(null);
```

**Problem:** Game still ended up in a different state. Extra input events were being sent, causing confusion.

### IFTalk's Final Solution (December 2024)

**The Problem:** VoxGlk wasn't including the `gen` field in specialresponse, causing glkapi.js to reject it due to generation mismatch.

**The Fix:** Add `gen: generation` to the specialresponse in VoxGlk's Dialog.open callback:

```javascript
// voxglk.js - Dialog.open callback
Dialog.open(writable, arg.specialinput.filetype, gameid, (fileref) => {
  if (acceptCallback) {
    acceptCallback({
      type: 'specialresponse',
      gen: generation,  // ← CRITICAL: Must match event_generation in glkapi.js
      response: 'fileref_prompt',
      value: fileref
    });
  }
});

// commands.js - Defer the callback (matches glkote.js's defer_func pattern)
window.addEventListener('iftalk-dialog-open', (e) => {
  const { callback } = e.detail;
  if (callback) {
    setTimeout(() => callback(null), 0);
  }
});
```

**Result:**
- User presses 'R' on Anchorhead intro → Game shows "Restore failed." and continues to intro text
- Game is in predictable state (ready for commands)
- Users use typed `SAVE`/`RESTORE` commands for IFTalk's custom save system

### Why This Works

1. **Correct generation number** - glkapi.js validates `obj.gen` matches `event_generation` before processing
2. **Proper event flow** - specialresponse reaches `gli_fileref_create_by_prompt_callback` which calls `VM.resume(null)`
3. **Game handles failure** - VM continues execution and outputs "Restore failed." message
4. **Deferred callback** - Matches glkote.js's `defer_func()` pattern, allows event loop to complete

### User Commands vs Game Commands

| Trigger | Handler | Behavior |
|---------|---------|----------|
| Press 'R' on intro | `initDialogInterceptor` | Returns `null`, game shows "Restore failed." |
| Type `RESTORE` | `interceptMetaCommand` | Shows our save list UI |
| Type `SAVE` | `interceptMetaCommand` | Prompts for save name |

### Key Learnings

1. **Generation numbers are critical** - glkapi.js validates generation numbers before processing events. Without `gen: generation` in the specialresponse, the event is silently rejected at line 156-159:
   ```javascript
   if (obj.gen != event_generation) {
     GlkOte.log('Input event had wrong generation number...');
     return;  // ← Event ignored!
   }
   ```

2. **VoxGlk must include gen field** - When creating specialresponse objects, VoxGlk must include the current generation number for glkapi.js to accept them.

3. **Defer callbacks for safety** - Using `setTimeout(() => callback(null), 0)` matches glkote.js's `defer_func()` pattern and prevents synchronous callback issues.

4. **VM.resume(null) is the key** - When `gli_fileref_create_by_prompt_callback` receives `value: null`, it calls `VM.resume(null)`, which makes the game output "Restore failed." and continue normally.

5. **Users use typed commands** - Typed `SAVE`/`RESTORE` commands provide a better UX with features like multiple named saves and autosave.

---

## References

- [Interpreter-Managed Saves in Glk](https://www.eblong.com/zarf/glk/terp-saving-notes.html)
- [GlkOte Documentation](https://eblong.com/zarf/glk/glkote/docs.html)
- [ifvms.js GitHub](https://github.com/curiousdannii/ifvms.js)
- [Parchment GitHub](https://github.com/curiousdannii/parchment)
- [Z-Machine Standards Document](https://inform-fiction.org/zmachine/standards/z1point1/sect06.html)
